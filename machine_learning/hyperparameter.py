# -*- coding: utf-8 -*-
"""hyperparameter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/152M49MFSvOsTZk5LqRXHXWOp9l3rZswJ
"""

from google.colab import drive
drive.mount('/content/drive')

import sklearn
from sklearn.model_selection import train_test_split, cross_val_score, cross_validate, GridSearchCV, RandomizedSearchCV, KFold
from sklearn.preprocessing import LabelBinarizer, LabelEncoder, StandardScaler, Normalizer, RobustScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.decomposition import PCA
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn import metrics, svm
from sklearn.neighbors import KNeighborsClassifier
import pandas as pd
import numpy as np

df = pd.read_csv('/content/drive/MyDrive/機器學習/secondary_data.csv', delimiter = ";", header = 'infer')
print(df, df.isnull().sum(),df.shape)

df = df.drop(['spore-print-color', 'stem-root','veil-color','veil-type','stem-surface','stem-root'], axis=1)
print(df.isnull().sum(),df.shape)

"""補missing value"""

df['cap-surface'].fillna(df['cap-surface'].mode()[0], inplace=True)
df['gill-attachment'].fillna(df['gill-attachment'].mode()[0], inplace=True)
df['gill-spacing'].fillna(df['gill-spacing'].mode()[0], inplace=True)
df['ring-type'].fillna(df['ring-type'].mode()[0], inplace=True)
print(df.isnull().sum())

lb = LabelEncoder()
df.iloc[:,0] = lb.fit_transform(df.iloc[:,0])
df.iloc[:,2] = lb.fit_transform(df.iloc[:,2])
df.iloc[:,3] = lb.fit_transform(df.iloc[:,3])
df.iloc[:,4] = lb.fit_transform(df.iloc[:,4])
df.iloc[:,5] = lb.fit_transform(df.iloc[:,5])
df.iloc[:,6] = lb.fit_transform(df.iloc[:,6])
df.iloc[:,7] = lb.fit_transform(df.iloc[:,7])
df.iloc[:,8] = lb.fit_transform(df.iloc[:,8])
df.iloc[:,11] = lb.fit_transform(df.iloc[:,11])
df.iloc[:,12] = lb.fit_transform(df.iloc[:,12])
df.iloc[:,13] = lb.fit_transform(df.iloc[:,13])
df.iloc[:,14] = lb.fit_transform(df.iloc[:,14])
df.iloc[:,15] = lb.fit_transform(df.iloc[:,15])
df

for i in range(0,16):
  print(df.columns[i], df[df.columns[i]].unique())

x = np.array(df.iloc[:,1:]) #x
y = df.iloc[:,0] #y
ss = StandardScaler()
scaled_data = ss.fit_transform(np.array(x).reshape(-1,15))
print(scaled_data, scaled_data.shape)

vt = VarianceThreshold(threshold=1e-03)
x_variance = vt.fit_transform(scaled_data)
cor = pd.DataFrame(x_variance)
cor = cor.corr()
print('correlation')
print(cor)
print('x variance')
print(x.var(axis=0), df.shape)

for i in range(0, len(x_variance[0])):
    for j in range(0, len(x_variance[0])):
        if cor[i][j] >=0.5 and cor[i][j]<1:
            print(cor.columns[i], cor.columns[j])

scaled_data = np.delete(x_variance, 0, 1)
scaled_data = np.delete(x_variance, 11, 1)
print(scaled_data, scaled_data.shape)

pca = PCA(n_components=3)
x_pca = pca.fit_transform(scaled_data)
print('pca')
print(x_pca)
print('pca variance')
print(x_pca.var(axis=0))

x_train, x_test, y_train, y_test = train_test_split(x_pca, y, test_size=0.2, random_state=1000)
lr = KNeighborsClassifier()
lr.fit(x_train, y_train)
y_pred = lr.predict(x_test)
score = cross_val_score(lr, x_train, y_train, cv=3, scoring='accuracy')
print("y predict:", y_pred)
y_t = np.array(y_test).reshape(1,-1)
print("y test:", y_t)
print(score, score.mean())

param_grid = [
    {
        'weights': ['uniform'],
        'n_neighbors': [i for i in range(1, 11)]
    },
    {
        'weights': ['distance'],
        'n_neighbors': [i for i in range(1, 11)],
        'p': [i for i in range(1, 6)]
    }
]
kfold = KFold(n_splits=3, shuffle=True, random_state=100)
grid_search = GridSearchCV(lr, param_grid, n_jobs=-1, cv=kfold, verbose=2)
grid_result = grid_search.fit(x_train, y_train)

print("tuned hpyerparameters(best parameters):",grid_result.best_params_)
print("accuracy:",grid_result.best_score_)
print(grid_result.best_estimator_)

knn = KNeighborsClassifier(n_neighbors=1, p=1, weights='distance')
knn.fit(x_train, y_train)
score = lr.score(x_test, y_test)
print(score)
score1 = cross_val_score(grid_result, x_train, y_train, cv=3, scoring='accuracy')
print(score1, score1.mean())